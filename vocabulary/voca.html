<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Test</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 폰트 로드 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Pretendard (한글/영어) -->
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" rel="stylesheet">
    <!-- Noto Sans JP (일본어) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* 로드한 폰트 적용 */
        body {
            font-family: 'Pretendard', 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            /* 모바일에서 탭 하이라이트 색상 투명하게 */
            -webkit-tap-highlight-color: transparent;
        }

        /* 정답/오답 버튼 스타일 (Tailwind보다 우선 적용되도록 !important 추가) */
        .option-button.correct {
            background-color: #28a745 !important; /* 초록색 */
            color: white !important;
            border-color: #28a745 !important;
            transform: scale(1.02);
        }

        .option-button.incorrect {
            background-color: #dc3545 !important; /* 빨간색 */
            color: white !important;
            border-color: #dc3545 !important;
        }
        
        /* 버튼 비활성화 시 스타일 */
        .option-button:disabled {
            opacity: 0.8;
            cursor: not-allowed;
        }

        /* 모달 스타일 */
        .modal.hidden {
            display: none;
        }
        .modal {
            display: flex;
        }
        /* 모달 열릴 때 애니메이션 */
        .modal:not(.hidden) #modal-content {
            opacity: 1;
            transform: scale(1);
        }
        /* 모달 닫힐 때 (JavaScript에서 클래스 제어 필요) */
        .modal.closing #modal-content {
            opacity: 0;
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="container mx-auto max-w-xl w-full">
        <!-- 1. 제목 및 모드 전환 버튼 -->
        <header class="flex justify-between items-center mb-4 sm:mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800">
                Vocabulary Test
            </h1>
            <button id="toggle-mode-btn" class="text-sm sm:text-base bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-3 sm:px-4 rounded-lg transition-all duration-200">
                단어 ↔ 뜻
            </button>
        </header>

        <main class="bg-white rounded-lg shadow-xl p-4 sm:p-6">
            <!-- 2. 문제 영역 -->
            <div id="question-container" class="mb-6 p-4 bg-blue-50 rounded-lg min-h-[80px] flex items-center justify-center">
                <h2 id="question-text" class="text-2xl sm:text-3xl font-bold text-blue-900 text-center break-keep">
                    Loading...
                </h2>
            </div>

            <!-- 3. 보기 버튼 영역 -->
            <div id="options-container" class="grid grid-cols-1 gap-3 sm:gap-4">
                <!-- 보기 버튼은 JavaScript로 생성됩니다. -->
            </div>

            <!-- 4. 정답/오답 피드백 -->
            <div id="feedback-container" class="mt-4 text-center h-8">
                <span id="feedback-text" class="text-2xl font-bold"></span>
            </div>

            <!-- 5. 결과 확인 버튼 -->
            <button id="show-results-btn" class="w-full mt-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105">
                결과 확인
            </button>
        </main>
    </div>

    <!-- 6. 결과 확인 모달 -->
    <div id="results-modal" class="modal hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
        <div class="bg-white w-full max-w-lg rounded-xl shadow-2xl overflow-hidden transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
            <!-- 모달 헤더 -->
            <div class="flex justify-between items-center p-5 border-b border-gray-200">
                <h3 class="text-xl font-bold text-gray-900">결과 확인</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 transition-all duration-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <!-- 모달 바디 -->
            <div class="p-6">
                <!-- 12.b. 전체 통계 -->
                <div class="text-center mb-4">
                    <span class="text-lg font-semibold text-gray-700">전체 통계:</span>
                    <span id="total-stats" class="text-lg font-bold text-blue-600 ml-2">정답 0 / 오답 0</span>
                </div>
                
                <!-- 12.c, e. 개별 통계 테이블 -->
                <div class="max-h-64 overflow-y-auto border border-gray-200 rounded-lg">
                    <table class="w-full min-w-full text-left">
                        <thead class="bg-gray-50 sticky top-0">
                            <tr>
                                <th id="results-table-header" class="p-3 text-sm font-semibold text-gray-600">문제</th>
                                <th class="p-3 text-sm font-semibold text-gray-600 text-center">정답</th>
                                <th class="p-3 text-sm font-semibold text-gray-600 text-center">오답</th>
                            </tr>
                        </thead>
                        <tbody id="stats-table-body" class="divide-y divide-gray-200">
                            <!-- 통계 데이터는 JavaScript로 생성됩니다. -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 요소 ---
            const questionText = document.getElementById('question-text');
            const optionsContainer = document.getElementById('options-container');
            const feedbackText = document.getElementById('feedback-text');
            const showResultsBtn = document.getElementById('show-results-btn');
            const toggleModeBtn = document.getElementById('toggle-mode-btn');
            
            // 모달 관련 요소
            const resultsModal = document.getElementById('results-modal');
            const modalContent = document.getElementById('modal-content');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const totalStats = document.getElementById('total-stats');
            const statsTableBody = document.getElementById('stats-table-body');
            const resultsTableHeader = document.getElementById('results-table-header'); // 결과 테이블 헤더

            // --- 상태 변수 ---
            let vocabList = []; // { word: '단어', meaning: '뜻' } 객체의 배열
            let stats = {}; // { '단어': { correct: 0, incorrect: 0 } }
            let totalCorrect = 0;
            let totalIncorrect = 0;
            let currentQuestion = null; // 현재 문제 { word: '...', meaning: '...' }
            let isAnswered = false; // 현재 문제에 답했는지 여부
            let currentMode = 'word-to-meaning'; // 'word-to-meaning' 또는 'meaning-to-word'

            // --- 초기화 및 데이터 로드 ---
            
            /**
             * 4. vocabulary.txt 파일에서 단어 로드
             * 14. 캐시 사용 안함 (fetch의 cache: 'no-store')
             */
            async function loadVocabulary() {
                try {
                    // 14. 캐시 방지를 위해 'no-store' 사용 및 타임스탬프 추가
                    const response = await fetch(`vocabulary.txt?t=${new Date().getTime()}`, {
                        cache: 'no-store' 
                    });
                    
                    if (!response.ok) {
                        throw new Error('vocabulary.txt 파일을 불러올 수 없습니다.');
                    }
                    
                    const text = await response.text();
                    
                    // 5, 7. 파일 파싱
                    vocabList = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0 && !line.startsWith('# ')) // 7. # 주석 제외
                        .map(line => {
                            const parts = line.split(',');
                            if (parts.length >= 2) {
                                const word = parts[0].trim();
                                const meaning = parts.slice(1).join(',').trim(); // 뜻에 콤마가 있어도 처리
                                return { word, meaning };
                            }
                            return null;
                        })
                        .filter(item => item !== null); // 형식이 잘못된 줄 제외

                    if (vocabList.length < 5) {
                        throw new Error('문제를 만들기에 단어 수가 부족합니다 (최소 5개 필요).');
                    }
                    
                    initializeStats();
                    nextQuestion();

                } catch (error) {
                    questionText.textContent = error.message;
                    questionText.classList.add('text-red-600');
                }
            }

            /**
             * 12. 통계 객체 초기화
             */
            function initializeStats() {
                stats = {};
                vocabList.forEach(item => {
                    // 단어를 key로 사용 (단어는 고유하다고 가정)
                    stats[item.word] = { correct: 0, incorrect: 0 };
                });
                totalCorrect = 0;
                totalIncorrect = 0;
            }


            // --- 문제 출제 로직 ---

            /**
             * 10. 다음 문제 출제 (랜덤, 반복)
             */
            function nextQuestion() {
                if (vocabList.length === 0) return;

                isAnswered = false;
                feedbackText.textContent = '';
                optionsContainer.innerHTML = ''; // 버튼 비우기

                // 1. 랜덤 문제 선택
                currentQuestion = vocabList[Math.floor(Math.random() * vocabList.length)];

                // 2. 문제 제시 (모드에 따라)
                if (currentMode === 'word-to-meaning') {
                    questionText.textContent = currentQuestion.word;
                } else {
                    questionText.textContent = currentQuestion.meaning;
                }

                // 6. 5가지 보기 생성
                
                // 1) 정답 보기
                let options = [currentQuestion];
                
                // 2) 오답 보기 4개 (정답과 중복되지 않게)
                const incorrectOptions = vocabList.filter(item => item.word !== currentQuestion.word);
                shuffleArray(incorrectOptions); // 오답 목록 섞기

                for (let i = 0; i < 4 && i < incorrectOptions.length; i++) {
                    options.push(incorrectOptions[i]);
                }

                // 3) 보기 섞기
                shuffleArray(options);

                // 6. 5가지 보기 버튼 생성
                options.forEach(item => {
                    const button = document.createElement('button');
                    button.classList.add(
                        'option-button', 'w-full', 'p-3', 'sm:p-4', // 13. 모바일/데스크탑 글자 크기 조정 (세로 패딩 축소)
                        'text-base', 'sm:text-lg', 
                        'font-medium', 'text-gray-700', 'bg-white', 
                        'border', 'border-gray-300', 'rounded-lg', 'shadow-sm',
                        'hover:bg-gray-100', 'hover:shadow-md', 'transition-all', 'duration-200',
                        'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-opacity-50',
                        'break-keep' // 단어 줄바꿈 방지 (단어가 너무 길면 어쩔 수 없음)
                    );
                    
                    // 모드에 따라 버튼 텍스트 설정
                    if (currentMode === 'word-to-meaning') {
                        button.textContent = item.meaning;
                    } else {
                        button.textContent = item.word;
                    }
                    
                    // 버튼에 데이터 저장 (정답 판별용)
                    button.dataset.word = item.word; 

                    button.addEventListener('click', () => handleAnswer(button));
                    optionsContainer.appendChild(button);
                });
            }

            /**
             * 8, 9. 정답 처리
             */
            function handleAnswer(selectedButton) {
                if (isAnswered) return; // 이미 답했으면 중복 처리 방지
                isAnswered = true;

                const selectedWord = selectedButton.dataset.word;
                const isCorrect = (selectedWord === currentQuestion.word);
                const currentStats = stats[currentQuestion.word];

                // 모든 버튼 비활성화
                disableButtons();

                if (isCorrect) {
                    // 8. 정답
                    selectedButton.classList.add('correct');
                    feedbackText.textContent = '정답';
                    feedbackText.classList.remove('text-red-500');
                    feedbackText.classList.add('text-green-500');
                    currentStats.correct++;
                    totalCorrect++;
                } else {
                    // 9. 오답
                    selectedButton.classList.add('incorrect');
                    feedbackText.textContent = '오답';
                    feedbackText.classList.remove('text-green-500');
                    feedbackText.classList.add('text-red-500');
                    currentStats.incorrect++;
                    totalIncorrect++;

                    // 정답 버튼 찾아서 초록색으로 표시
                    const correctButton = Array.from(optionsContainer.children).find(
                        btn => btn.dataset.word === currentQuestion.word
                    );
                    if (correctButton) {
                        correctButton.classList.add('correct');
                    }
                }

                // 10. 1.5초 후 다음 문제로
                setTimeout(nextQuestion, 1500);
            }

            /**
             * 17. 모드 전환
             */
            function toggleMode() {
                currentMode = (currentMode === 'word-to-meaning') ? 'meaning-to-word' : 'word-to-meaning';
                
                // 버튼 텍스트 업데이트
                toggleModeBtn.textContent = (currentMode === 'word-to-meaning') ? '단어 ↔ 뜻' : '뜻 ↔ 단어';
                
                // 통계 초기화 및 새 문제 시작
                initializeStats();
                nextQuestion();
            }


            // --- 유틸리티 함수 ---

            function disableButtons() {
                Array.from(optionsContainer.children).forEach(btn => {
                    btn.disabled = true;
                });
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }


            // --- 모달 관련 함수 ---

            /**
             * 11. 결과 확인 모달 표시
             */
            function showResults() {
                // 12.b. 전체 통계
                totalStats.textContent = `정답 ${totalCorrect} / 오답 ${totalIncorrect}`;

                // 모드에 따라 테이블 헤더 변경
                if (currentMode === 'word-to-meaning') {
                    resultsTableHeader.textContent = '단어 (뜻)';
                } else {
                    resultsTableHeader.textContent = '뜻 (단어)';
                }
                
                // 12.c. 개별 통계 테이블 생성
                statsTableBody.innerHTML = ''; // 테이블 비우기

                // vocabList 순서대로 테이블 생성 (stats 객체는 순서를 보장하지 않음)
                vocabList.forEach(item => {
                    const { word, meaning } = item;
                    const s = stats[word];

                    // 요청 사항 (1, 2): 정답 또는 오답 횟수가 1 이상인 (즉, 출제된) 문제만 표시
                    if (s && (s.correct > 0 || s.incorrect > 0)) {
                        
                        // 12.d. 틀린 횟수가 1 이상이면 빨간색
                        const itemClass = s.incorrect > 0 ? 'text-red-600 font-semibold' : 'text-gray-900';
                        
                        // 요청 사항: 모드에 따라 결과 포맷 변경
                        let itemText = '';
                        if (currentMode === 'word-to-meaning') {
                            // "단어 (뜻)"
                            itemText = `${word} (${meaning})`;
                        } else {
                            // "뜻 (단어)"
                            itemText = `${meaning} (${word})`;
                        }

                        const row = `
                            <tr class="hover:bg-gray-50">
                                <td class="p-3 text-sm ${itemClass}">${itemText}</td>
                                <td class="p-3 text-sm text-gray-700 text-center">${s.correct}</td>
                                <td class="p-3 text-sm text-gray-700 text-center">${s.incorrect}</td>
                            </tr>
                        `;
                        statsTableBody.innerHTML += row;
                    }
                });
                
                // 12.a. 모달 팝업
                resultsModal.classList.remove('hidden');
                // 애니메이션 트리거 (CSS 참조)
                setTimeout(() => {
                    modalContent.classList.add('opacity-1', 'scale-100');
                    modalContent.classList.remove('opacity-0', 'scale-95');
                }, 10); // 10ms 딜레이로 브라우저가 .hidden 제거를 인지하게 함
            }

            /**
             * 12.a. 모달 닫기
             */
            function closeModal() {
                modalContent.classList.remove('opacity-1', 'scale-100');
                modalContent.classList.add('opacity-0', 'scale-95');
                
                resultsModal.classList.add('closing'); // 닫힘 애니메이션 클래스 (선택사항)

                // CSS transition 시간(300ms) 후 모달 숨기기
                setTimeout(() => {
                    resultsModal.classList.add('hidden');
                    resultsModal.classList.remove('closing');
                }, 300);
            }


            // --- 이벤트 리스너 ---
            showResultsBtn.addEventListener('click', showResults);
            closeModalBtn.addEventListener('click', closeModal);
            toggleModeBtn.addEventListener('click', toggleMode);

            // 모달 바깥 영역 클릭 시 닫기
            resultsModal.addEventListener('click', (e) => {
                if (e.target === resultsModal) {
                    closeModal();
                }
            });

            // --- 프로그램 시작 ---
            loadVocabulary();
        });
    </script>

</body>
</html>

